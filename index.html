<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section><code>this</code></section>
        <section>What is <code>this</code>?</section>
        <section>Keyword <code>this</code> is used to access the current object from the method
					<pre><code data-trim>
						var user = {
						  name: 'John',
						  sayHi: function() {
								alert(this.name);
							}
						};
						user.sayHi(); // John (sayHi in context of user)
					</code></pre>
        </section>
        <section>
					What will happen if we will not use <code>this</code>?
          <pre class="fragment" data-fragment-index="1"><code data-trim>
            var user = {
            name: 'John',
              sayHi: function() {
                alert(user.name);
              }
            };
          </code></pre>
          <pre class="fragment" data-fragment-index="2"><code data-trim>
            var admin = user;
            user = null;
          </code></pre>
          <pre class="fragment" data-fragment-index="3"><code data-trim>
						admin.sayHi(); // oops! Error
					</code></pre>
				</section>
				<section>Through <code>this</code> method can not only refer to any property of the object, but also pass somewhere a link to the object itself:
					<pre><code data-trim>
						var user = {
							name: 'John',

							sayHi: function() {
								showName(this); // pass current object in showName
							}
						};

						function showName(namedObj) {
							alert(namedObj.name);
						}

						user.sayHi(); // John
					</code></pre>	
				</section>
				<section>
					<p>The value of <code>this</code> is called the context of the call and will be determined at the time of the function call.</p>
					<pre class="fragment" data-fragment-index="1"><code data-trim>
						function sayHi() {
							alert(this.firstName);
						}
					</code></pre>
					<pre class="fragment" data-fragment-index="2"><code data-trim>
						var user = { firstName: "John" };
						var admin = { firstName: "admin" };

						function func() {
							alert( this.firstName );
						}

						user.f = func;
						admin.g = func;
					</code></pre>
					<pre class="fragment" data-fragment-index="3"><code data-trim>
						user.f(); // John
						admin.g(); // admin
						admin['g'](); // admin
					</code></pre>
				</section>
				<section>
					<p>The context of <code>this</code> is in no way attached to the function, even if it was created in the object declaration. To <code>this</code> passed, you need to call the function through the point (or square brackets).</p>
					<pre class="fragment" data-fragment-index="1"><code data-trim>
						var user = {
							name: "John",
							hi: function() { alert(this.name); },
							bye: function() { alert("Bye"); }
						};							
					</code></pre>
					<pre class="fragment" data-fragment-index="2"><code data-trim>
						hi(); // error (is not defined)
						user.hi(); // John (simple call will work)
					</code></pre>
					<pre class="fragment" data-fragment-index="3"><code data-trim>
						user.hi; // returns body of hi method
						user.bye; // returns body of bye method
					</code></pre>
				</section>
				<section>
					<p class="fragment" data-fragment-index="1">Global Context</p>
					<pre class="fragment" data-fragment-index="2"><code data-trim>
						console.log(this.document === document); // true

						// In web browsers, the window object is also the global object:
						console.log(this === window); // true

						this.a = 37;
						console.log(window.a); // 37
					</code></pre>
				</section>
				<section>
					<p class="fragment" data-fragment-index="1">Function context</p>
					<pre class="fragment" data-fragment-index="2"><code data-trim>
						// Simple call
						function f1() {
							return this;
						}
						// In a browser:
						f1() === window; // true 

						// In Node:
						f1() === global; // true
					</code></pre>
					<pre class="fragment" data-fragment-index="3"><code data-trim>
						// In strict mode
						function f2() {
							'use strict'; // see strict mode
							return this;
						}
						
						f2() === undefined; // true
					</code></pre>
				</section>
				<section>
					<p class="fragment" data-fragment-index="1">Arrow functions</p>
					<pre class="fragment" data-fragment-index="2"><code data-trim>
						var globalObject = this;
						var foo = (() => this);
						console.log(foo() === globalObject); // true
					</code></pre>
					<pre class="fragment" data-fragment-index="3"><code data-trim>
						var obj = {foo: foo};
						console.log(obj.foo() === globalObject); // true
					</code></pre>
				</section>
				<section>
					<p class="fragment" data-fragment-index="1">As a constructor</p>
					<pre class="fragment" data-fragment-index="2"><code data-trim>
						function C(){
							this.a = 37;
						}

						var o = new C();
						console.log(o.a); // logs 37
					</code></pre>
					<pre class="fragment" data-fragment-index="3"><code data-trim>
						function C2(){
							this.a = 37;
							return {a:38};
						}

						o = new C2();
						console.log(o.a); // logs 38
					</code></pre>
				</section>
				<section>
					<p><code>call</code> and <code>apply</code></p>
					<pre class="fragment" data-fragment-index="1"><code data-trim>
						function add(c, d){
							return this.a + this.b + c + d;
						}
		
						var o = {a:1, b:3};
								
						add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
								
						add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34
					</code></pre>
				</section>
				<section>
					<p><code>bind</code></p>
					<pre class="fragment" data-fragment-index="1"><code data-trim>
						function f(){
							return this.a;
						}

						var g = f.bind({a:"azerty"});
						console.log(g()); // azerty
					</code></pre>
					<pre class="fragment" data-fragment-index="2"><code data-trim>
						var h = g.bind({a: 'yoo'}); // bind only works once!
						console.log(h()); // azerty
					</code></pre>
					<pre class="fragment" data-fragment-index="3"><code data-trim>
						var o = {a: 37, f: f, g: g, h: h};
						console.log(o.a, o.f(), o.g(), o.h()); // 37,37, azerty, azerty
					</code></pre>
				</section>
				<section>
					<p>Polyfill of <code>bind()</code></p>
					<pre><code data-trim>
					  Function.prototype.bind = function(thisArgs) {
						  var that = this;
						  var args = Array.prototype.slice.call(arguments, 1);
						  var boundFunc = function() {
						    args = args.concat(Array.prototype.slice.call(arguments));
						    return that.apply(thisArgs, args);
					    }
					    return boundFunc;
					  }
					</code></pre>
				</section>
				<section>Thanks for you attention!</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
